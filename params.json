{
  "name": "CakeParse",
  "tagline": "Simple parser combinator library for Kotlin",
  "body": "# CakeParse\r\n\r\nCakeParse is a lexer and recursive descent parser combinator library for [Kotlin]. It can parse any LL(*) grammer, and contains line/column number error reporting. A [calculator expression parser][Calculator] example is included.\r\n\r\n## Usage\r\n\r\n### Step 0: Setup\r\n\r\nCheck the version badge for the latest version number:\r\n[![Version badge](https://api.bintray.com/packages/sargunster/maven/cakeparse/images/download.svg)](https://bintray.com/sargunster/maven/cakeparse/_latestVersion)\r\n\r\n#### Gradle\r\n\r\n``` groovy\r\nrepositories {\r\n  jcenter()\r\n}\r\n\r\ndependencies {\r\n  compile \"me.sargunvohra.lib:CakeParse:<version>\"\r\n}\r\n```\r\n\r\n#### Kobalt\r\n\r\n``` kotlin\r\ndependencies {\r\n  compile(\"me.sargunvohra.lib.CakeParse:<version>\")\r\n}\r\n```\r\n\r\n### Step 1: Tokens\r\n\r\nDefine your tokens by name and regex. These make up the building blocks of your parser rules. Whitespace can be ignored by defining a token with `ignore = true`.\r\n\r\n``` kotlin\r\nimport me.sargunvohra.lib.cakeparse.api.*\r\n\r\nval number = token(\"number\", \"[0-9]+\")\r\nval plus = token(\"plus\", \"\\\\+\")\r\nval space = token(\"space\", \"[ \\\\t\\\\r]+\", ignore = true)\r\n// ...\r\n```\r\n\r\n### Step 2: Productions\r\n\r\nDefine your productions using the the combinators and other methods.\r\n\r\n``` kotlin\r\nval parenExpr = lPar then expr before rPar\r\nval primExpr = number map { it.raw.toInt() } or parenExpr\r\nval goal = oneOrMore(number)\r\n// ...\r\n```\r\n\r\nThe available combinators are:\r\n\r\n- `a or b`: Parse `a` if possible, otherwise parse `b`. Return the result of the successful parse.\r\n- `a and b`: Parse `a` and then `b`. Return a `Pair<K,V>` of both results.\r\n- `a then b`: Just like `and`, but return the result of `b`.\r\n- `a before b`: Just like `and`, but return the result of `a`.\r\n- `a map { /* transformer */ }`: Just like `a`, but map the result to a new result using the transformer.\r\n- `repeat(n, a)`: Match `a` in a sequence **exactly** `n` times, and return a result containing a list of all the matches.\r\n- `atLeast(n, a)`: Just like `repeat`, but match **at least** `n` times\r\n\r\nThere are also a number of convenience parsers:\r\n\r\n- `empty<T>()`: Match an empty input and return a `null` result of type `T`. \r\n- `optional(a)`: Match `a` if possible, otherwise return `null`.\r\n- `zeroOrMore(a)`: Just like `atLeast(0, a)`\r\n- `oneOrMore(a)`: Just like `atLeast(1, a)`\r\n\r\n### Step 3: Parse\r\n\r\nPass your input through a lexer, and then a parser.\r\n\r\n``` kotlin\r\nval tokens = setOf(token1, token2, token3)\r\ntry {\r\n  val input = System.in\r\n  val result = tokens.lexer().lex(input).parseToEnd(goal).value\r\n  println(\"Result: $result\")\r\n} catch (e: LexerException) {\r\n  System.err.println(\"Lexing error: ${e.message}\")\r\n} catch (e: ParserException) {\r\n  System.err.println(\"Parsing error: ${e.message}\")\r\n}\r\n```\r\n\r\n### Note: Recursion\r\n\r\nIf you have a rule or system of rules that involves recursion, then you'll have to use the `ref` function to make it work. Be sure to explicitly specify the type of a ref. This is needed because the compiler can't infer the type of a recursive reference.\r\n\r\n``` kotlin\r\n// put all tokens first\r\nval lParen = token(\"lParen\", \"\\\\(\")\r\nval rParen = token(\"rParen\", \"\\\\)\")\r\n\r\n// then put all refs\r\nval parenRef: Parser<Token> = ref({ paren })\r\n\r\n// then put all rules\r\nval paren = (lParen then parenRef before rParen) or empty()\r\n```\r\n\r\nThe best way to do this is to put your goal rule at the bottom, all rules that depend on it above, all rules that depend on those above those, etc. Anywhere a rule refers to itself or the rule below, use a `ref`.\r\n\r\n[Kotlin]: https://kotlinlang.org/\r\n[Calculator]: https://github.com/sargunster/CakeParse/blob/master/src/test/kotlin/me/sargunvohra/lib/cakeparse/example/Calculator.kt",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}