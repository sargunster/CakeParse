{"name":"CakeParse","tagline":"Simple parser combinator library for Kotlin","body":"# CakeParse\r\n\r\nCakeParse is a lexer and recursive descent parser combinator library for [Kotlin](https://kotlinlang.org/). It can parse any LL(*) grammer, and contains line/column number error reporting. A [calculator expression parser](./src/test/kotlin/me/sargunvohra/lib/cakeparse/example/Calculator.kt) example is included.\r\n\r\n## Usage\r\n\r\n### Step 0: Setup\r\n\r\nCheck the [releases tab](https://github.com/sargunster/CakeParse/releases) for the latest version number.\r\n\r\n#### Gradle\r\n\r\n``` groovy\r\nrepositories {\r\n  jcenter()\r\n}\r\n\r\ndependencies {\r\n  compile \"me.sargunvohra.lib:CakeParse:<version>\"\r\n}\r\n```\r\n\r\n#### Kobalt\r\n\r\n``` kotlin\r\ndependencies {\r\n  compile(\"me.sargunvohra.lib.CakeParse:<version>\")\r\n}\r\n```\r\n\r\n#### Manual\r\n\r\nDownload the latest version from the [releases tab](https://github.com/sargunster/CakeParse/releases) and add the jar to your classpath. This method is not reccomended.\r\n\r\n### Step 1: Tokens\r\n\r\nDefine your tokens by name and regex. These make up the building blocks of your parser rules.\r\n\r\n``` kotlin\r\nimport me.sargunvohra.lib.cakeparse.api.*\r\n\r\nval number = token(\"number\", \"[0-9]+\")\r\nval plus = token(\"plus\", \"\\\\+\")\r\nval space = token(\"space\", \"[ \\\\t\\\\r]+\", ignore = true)\r\n// ...\r\n```\r\n\r\n### Step 2: Productions\r\n\r\nDefine your productions using the rules in [Combinators.kt](./src/main/kotlin/me/sargunvohra/lib/cakeparse/api/Combinators.kt) and [Convenience.kt](src/main/kotlin/me/sargunvohra/lib/cakeparse/api/Convenience.kt).\r\n\r\n``` kotlin\r\nval parenExpr = lPar then expr before rPar\r\nval primExpr = number map { it.raw.toInt() } or parenExpr\r\nval goal = oneOrMore(number)\r\n// ...\r\n```\r\n\r\n### Step 3: Parse\r\n\r\nPass your input through a lexer, and then a parser.\r\n\r\n``` kotlin\r\nval tokens = setOf(token1, token2, token3)\r\ntry {\r\n  val input = System.in\r\n  val result = tokens.lexer().lex(input).parseToEnd(goal).value\r\n  println(\"Result: $result\")\r\n} catch (e: LexerException) {\r\n  System.err.println(\"Lexing error: ${e.message}\")\r\n} catch (e: ParserException) {\r\n  System.err.println(\"Parsing error: ${e.message}\")\r\n}\r\n```\r\n\r\n### Note: Recursion\r\n\r\nIf you have a rule or system of rules that involves recursion, then you'll have to use the `ref` function to make sure it works. Make sure to explicitly specify the type of a ref. This is needed because the compiler can't infer the type of a recursive reference.\r\n\r\n``` kotlin\r\n// put all tokens first\r\nval lParen = token(\"lParen\", \"\\\\(\")\r\nval rParen = token(\"rParen\", \"\\\\)\")\r\n\r\n// then put all refs\r\nval parenRef: Parser<Token> = ref({ paren })\r\n\r\n// then put all rules\r\nval paren = (lParen then parenRef before rParen) or empty()\r\n```\r\n\r\nThe best way to do this is to put your goal rule at the bottom, all rules that depend on it above, all rules that depend on those above those, etc. Anywhere a rule refers to itself or the rule below, use a `ref`.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}