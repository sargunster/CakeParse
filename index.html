<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>CakeParse by sargunster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CakeParse</h1>
      <h2 class="project-tagline">Simple parser combinator library for Kotlin</h2>
      <a href="https://github.com/sargunster/cakeparse" class="btn">View on GitHub</a>
      <a href="https://github.com/sargunster/cakeparse/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/sargunster/cakeparse/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="cakeparse" class="anchor" href="#cakeparse" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CakeParse</h1>

<p>CakeParse is a lexer and recursive descent parser combinator library for <a href="https://kotlinlang.org/">Kotlin</a>. It can parse any LL(*) grammer, and contains line/column number error reporting. A <a href="https://github.com/sargunster/CakeParse/blob/master/src/test/kotlin/me/sargunvohra/lib/cakeparse/example/Calculator.kt">calculator expression parser</a> example is included.</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h2>

<h3>
<a id="step-0-setup" class="anchor" href="#step-0-setup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 0: Setup</h3>

<p>Check the version badge for the latest version number:
<a href="https://bintray.com/sargunster/maven/cakeparse/_latestVersion"><img src="https://api.bintray.com/packages/sargunster/maven/cakeparse/images/download.svg" alt="Version badge"></a></p>

<h4>
<a id="gradle" class="anchor" href="#gradle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Gradle</h4>

<div class="highlight highlight-source-groovy"><pre>repositories {
  jcenter()
}

dependencies {
  compile <span class="pl-s"><span class="pl-pds">"</span>me.sargunvohra.lib:CakeParse:&lt;version&gt;<span class="pl-pds">"</span></span>
}</pre></div>

<h4>
<a id="kobalt" class="anchor" href="#kobalt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Kobalt</h4>

<div class="highlight highlight-source-Kotlin"><pre>dependencies {
  compile(<span class="pl-s"><span class="pl-pds">"</span>me.sargunvohra.lib.CakeParse:&lt;version&gt;<span class="pl-pds">"</span></span>)
}</pre></div>

<h3>
<a id="step-1-tokens" class="anchor" href="#step-1-tokens" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 1: Tokens</h3>

<p>Define your tokens by name and regex. These make up the building blocks of your parser rules. Whitespace can be ignored by defining a token with <code>ignore = true</code>.</p>

<div class="highlight highlight-source-Kotlin"><pre><span class="pl-k">import</span> me.sargunvohra.lib.cakeparse.api.*

<span class="pl-k">val</span> <span class="pl-en">number</span> <span class="pl-k">=</span> token(<span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>[0-9]+<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">plus</span> <span class="pl-k">=</span> token(<span class="pl-s"><span class="pl-pds">"</span>plus<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>+<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">space</span> <span class="pl-k">=</span> token(<span class="pl-s"><span class="pl-pds">"</span>space<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>[ <span class="pl-cce">\\</span>t<span class="pl-cce">\\</span>r]+<span class="pl-pds">"</span></span>, ignore <span class="pl-k">=</span> <span class="pl-c1">true</span>)
<span class="pl-c">// ...</span></pre></div>

<h3>
<a id="step-2-productions" class="anchor" href="#step-2-productions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 2: Productions</h3>

<p>Define your productions using the the combinators and other methods.</p>

<div class="highlight highlight-source-Kotlin"><pre><span class="pl-k">val</span> <span class="pl-en">parenExpr</span> <span class="pl-k">=</span> lPar then expr before rPar
<span class="pl-k">val</span> <span class="pl-en">primExpr</span> <span class="pl-k">=</span> number map { it<span class="pl-k">.</span>raw<span class="pl-k">.</span>toInt() } or parenExpr
<span class="pl-k">val</span> <span class="pl-en">goal</span> <span class="pl-k">=</span> oneOrMore(number)
<span class="pl-c">// ...</span></pre></div>

<p>The available combinators are:</p>

<ul>
<li>
<code>a or b</code>: Parse <code>a</code> if possible, otherwise parse <code>b</code>. Return the result of the successful parse.</li>
<li>
<code>a and b</code>: Parse <code>a</code> and then <code>b</code>. Return a <code>Pair&lt;K,V&gt;</code> of both results.</li>
<li>
<code>a then b</code>: Just like <code>and</code>, but return the result of <code>b</code>.</li>
<li>
<code>a before b</code>: Just like <code>and</code>, but return the result of <code>a</code>.</li>
<li>
<code>a map { /* transformer */ }</code>: Just like <code>a</code>, but map the result to a new result using the transformer.</li>
<li>
<code>repeat(n, a)</code>: Match <code>a</code> in a sequence <strong>exactly</strong> <code>n</code> times, and return a result containing a list of all the matches.</li>
<li>
<code>atLeast(n, a)</code>: Just like <code>repeat</code>, but match <strong>at least</strong> <code>n</code> times</li>
</ul>

<p>There are also a number of convenience parsers:</p>

<ul>
<li>
<code>empty&lt;T&gt;()</code>: Match an empty input and return a <code>null</code> result of type <code>T</code>. </li>
<li>
<code>optional(a)</code>: Match <code>a</code> if possible, otherwise return <code>null</code>.</li>
<li>
<code>zeroOrMore(a)</code>: Just like <code>atLeast(0, a)</code>
</li>
<li>
<code>oneOrMore(a)</code>: Just like <code>atLeast(1, a)</code>
</li>
</ul>

<h3>
<a id="step-3-parse" class="anchor" href="#step-3-parse" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 3: Parse</h3>

<p>Pass your input through a lexer, and then a parser.</p>

<div class="highlight highlight-source-Kotlin"><pre><span class="pl-k">val</span> <span class="pl-en">tokens</span> <span class="pl-k">=</span> setOf(token1, token2, token3)
<span class="pl-k">try</span> {
  <span class="pl-k">val</span> <span class="pl-en">input</span> <span class="pl-k">=</span> System<span class="pl-k">.</span><span class="pl-k">in</span>
  <span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> tokens<span class="pl-k">.</span>lexer()<span class="pl-k">.</span>lex(input)<span class="pl-k">.</span>parseToEnd(goal)<span class="pl-k">.</span>value
  println(<span class="pl-s"><span class="pl-pds">"</span>Result: <span class="pl-v">$result</span><span class="pl-pds">"</span></span>)
} <span class="pl-k">catch</span> (e<span class="pl-k">:</span> LexerException) {
  System<span class="pl-k">.</span>err<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>Lexing error: <span class="pl-v">${e.message}</span><span class="pl-pds">"</span></span>)
} <span class="pl-k">catch</span> (e<span class="pl-k">:</span> ParserException) {
  System<span class="pl-k">.</span>err<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>Parsing error: <span class="pl-v">${e.message}</span><span class="pl-pds">"</span></span>)
}</pre></div>

<h3>
<a id="note-recursion" class="anchor" href="#note-recursion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Note: Recursion</h3>

<p>If you have a rule or system of rules that involves recursion, then you'll have to use the <code>ref</code> function to make it work. Be sure to explicitly specify the type of a ref. This is needed because the compiler can't infer the type of a recursive reference.</p>

<div class="highlight highlight-source-Kotlin"><pre><span class="pl-c">// put all tokens first</span>
<span class="pl-k">val</span> <span class="pl-en">lParen</span> <span class="pl-k">=</span> token(<span class="pl-s"><span class="pl-pds">"</span>lParen<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>(<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">rParen</span> <span class="pl-k">=</span> token(<span class="pl-s"><span class="pl-pds">"</span>rParen<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>)<span class="pl-pds">"</span></span>)

<span class="pl-c">// then put all refs</span>
<span class="pl-k">val</span> <span class="pl-en">parenRef</span><span class="pl-k">:</span> Parser&lt;Token&gt; <span class="pl-k">=</span> ref({ paren })

<span class="pl-c">// then put all rules</span>
<span class="pl-k">val</span> <span class="pl-en">paren</span> <span class="pl-k">=</span> (lParen then parenRef before rParen) or empty()</pre></div>

<p>The best way to do this is to put your goal rule at the bottom, all rules that depend on it above, all rules that depend on those above those, etc. Anywhere a rule refers to itself or the rule below, use a <code>ref</code>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/sargunster/cakeparse">CakeParse</a> is maintained by <a href="https://github.com/sargunster">sargunster</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
